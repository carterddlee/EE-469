`ifndef _core_v
`define _core_v
`include "system.sv"
`include "base.sv"
`include "memory_io.sv"
`include "memory.sv"


module core(
    input logic       clk
    ,input logic      reset
    ,input logic      [`word_address_size-1:0] reset_pc
    ,output memory_io_req   inst_mem_req
    ,input  memory_io_rsp   inst_mem_rsp
    ,output memory_io_req   data_mem_req
    ,input  memory_io_rsp   data_mem_rsp
    );

typedef enum {
    stage_fetch
    ,stage_decode
    ,stage_execute
    ,stage_mem
    ,stage_writeback
}   stage;

stage   current_stage;

logic [31:0] instruction;
logic [4:0] rd;
logic [4:0] rs1;
logic [4:0] rs2;
logic signed [31:0] imm;
logic [6:0] opcode;
logic [2:0] funct3;
logic [6:0] funct7;


word    pc;
always_comb begin # fetch stage
    if (current_stage == stage_fetch) begin
    	inst_mem_req.addr = pc;
        inst_mem_req.do_read  = 4'b1111;
        inst_mem_req.valid = true;
	end
end

always_comb begin # decode stage
    if (current_stage == stage_decode) begin
        instruction = inst_mem_rsp.data; 
        rd = instruction[11:7];
        rs1 = instruction[19:15];
        rs2 = instruction[24:20];
        funct3 = instruction[14:12];
        funct7 = instruction[31:25];
        opcode = instruction[6:0];
        imm = find_imm(opcode, instruction);
	end
end

always @(posedge clk) begin
   if (reset)
      pc <= reset_pc;

   if (current_stage == stage_writeback)
      pc <= pc + 4;
end

always @(posedge clk) begin
    if (reset)
        current_stage <= stage_fetch;
    else begin
        case (current_stage)
            stage_fetch:
                current_stage <= stage_decode;
            stage_decode:
                current_stage <= stage_execute;
            stage_execute:
                current_stage <= stage_mem;
            stage_mem:
                current_stage <= stage_writeback;
            stage_writeback:
                current_stage <= stage_fetch;
            default: begin
                $display("Should never get here");
                current_stage <= stage_fetch;
            end
        endcase
    end
end


endmodule

`endif


function logic [31:0] find_imm(
    input logic [6:0] opcode,
    input logic [31:0] instruction
);
    logic signed [31:0] imm;
    case (opcode)
        // I-type: LOAD, OP-IMM, JALR
        7'b0000011,
        7'b0010011,
        7'b1100111: begin
            imm = {{20{instruction[31]}}, instruction[31:20]};
        end
        
        // S-type: STORE
        7'b0100011: begin
            imm = {{20{instruction[31]}}, instruction[31:25], instruction[11:7]};
        end
        
        // B-type: BRANCH
        7'b1100011: begin
            imm = {{19{instruction[31]}}, instruction[31], instruction[7],
                   instruction[30:25], instruction[11:8], 1'b0};
        end
        
        // U-type: LUI, AUIPC
        7'b0110111,
        7'b0010111: begin
            imm = {instruction[31:12], 12'b0};
        end
        
        // J-type: JAL
        7'b1101111: begin
            imm = {{11{instruction[31]}}, instruction[31], instruction[19:12],
                   instruction[20], instruction[30:21], 1'b0};
        end
        
        default: imm = '0;
    endcase
    return imm;
endfunction
