`ifndef _core_v
`define _core_v
`include "system.sv"
`include "base.sv"
`include "memory_io.sv"
`include "memory.sv"
`include "lab1.sv"       # to use functions from lab1


module core(
    input logic       clk
    ,input logic      reset
    ,input logic      [`word_address_size-1:0] reset_pc
    ,output memory_io_req   inst_mem_req
    ,input  memory_io_rsp   inst_mem_rsp
    ,output memory_io_req   data_mem_req
    ,input  memory_io_rsp   data_mem_rsp
    );

typedef enum {
    stage_fetch
    ,stage_decode
    ,stage_execute
    ,stage_mem
    ,stage_writeback
}   stage;

stage   current_stage;
logic [31:0] registers [31:0];
initial begin
    for (int i=0; i < 32; i++) begin  
        registers[i] = 32'b0;
    end
end



logic [31:0] instruction;
logic [4:0] rd;
logic [4:0] rs1;
logic [4:0] rs2;
logic signed [31:0] imm;
logic [6:0] opcode;
logic [2:0] funct3;
logic [6:0] funct7;
string mnemonic;

logic [31:0] rs1_data;
logic [31:0] rs2_data;
logic [31:0] alu_result;

word    pc;
always_comb begin
    if (current_stage == stage_fetch) begin
        inst_mem_req.addr = pc;
        inst_mem_req.do_read = 4'b1111;
        inst_mem_req.valid = 1'b1;
    end else begin
        inst_mem_req.addr = pc;
        inst_mem_req.do_read = 4'b0000;
        inst_mem_req.valid = 1'b0;
    end
    inst_mem_req.do_write = 4'b0000;
    inst_mem_req.data = 32'b0;
end

always_comb begin # decode stage
    if (current_stage == stage_decode) begin
        instruction = inst_mem_rsp.data; 
        rd = instruction[11:7];
        rs1 = instruction[19:15];
        rs2 = instruction[24:20];
        funct3 = instruction[14:12];
        funct7 = instruction[31:25];
        opcode = instruction[6:0];
        print_instruction(pc, instruction);
        imm = find_imm(opcode, instruction);
        mnemonic = find_instruct(opcode, funct3, funct7);
        rs1_data = (rs1 == 5'b0) ? 32'b0 : registers[rs1]; 
        rs2_data = (rs2 == 5'b0) ? 32'b0 : registers[rs2];  
        
	end
end

always_comb begin # execute stage
    if (current_stage == stage_execute) begin
        case(mnemonic)
            "add":  alu_result = rs1_data + rs2_data;
            "sub":
        endcase

	end
end


always_ff @(posedge clk) begin
    if (reset) begin
        current_stage <= stage_fetch;
        pc <= reset_pc;
        for (int i = 0; i < 32; i++) begin
            registers[i] <= 32'b0;
        end
    end else begin
        case (current_stage)
            stage_fetch:
                current_stage <= stage_decode;
            stage_decode:
                current_stage <= stage_execute;
            stage_execute:
                current_stage <= stage_mem;
            stage_mem:
                current_stage <= stage_writeback;
            stage_writeback: begin
                // Register writeback
                if (rd != 5'b0) begin
                    registers[rd] <= alu_result;
                end
                // PC increment
                pc <= pc + 4;
                // Return to fetch
                current_stage <= stage_fetch;
            end
            default: begin
                $display("Should never get here");
                current_stage <= stage_fetch;
            end
        endcase
    end
end

endmodule

`endif
